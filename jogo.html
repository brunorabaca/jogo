<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Floresta Fantasma - Top Down</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a2e; /* Fundo escuro fora do mapa */
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            image-rendering: pixelated;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
        }

        #game-ui {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            text-align: center;
            pointer-events: none;
            display: none;
            text-shadow: 4px 4px 0px #000;
            z-index: 10;
        }

        h1 {
            font-size: 4rem;
            margin-bottom: 20px;
            font-weight: bold;
            letter-spacing: -2px;
        }

        p {
            font-size: 1.5rem;
            color: #f1c40f;
        }

        .instruction {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            pointer-events: none;
            text-shadow: 2px 2px 0 #000;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <div id="game-ui">
        <h1 id="ui-title">GAME OVER</h1>
        <p id="ui-subtitle">PRESSIONE ESPAÇO</p>
    </div>

    <div class="instruction">
        WASD: Mover • MOUSE: Mirar • CLIQUE: Atacar
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * CONFIGURAÇÃO E VARIÁVEIS GLOBAIS
 */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const uiElement = document.getElementById('game-ui');
const uiTitle = document.getElementById('ui-title');

ctx.imageSmoothingEnabled = false;

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let animationId;
let score = 0;
let isGameOver = false;
let globalFrame = 0;

// Inputs
const mouse = { x: canvas.width / 2, y: canvas.height / 2, mapX: 0, mapY: 0, down: false };
const keys = { w: false, a: false, s: false, d: false, " ": false };

// Configurações do Mapa
const TILE_SIZE = 64; // Tamanho de cada quadrado do mapa
const MAP_DATA = [
    "aaaaaaaaaaaaaaaaa",
    "aaaaaaccGccaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaccSccaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaacPcaaaaaaa",
    "aaaaaaacccaaaaaaa",
    "aaaaaaaaaaaaaaaaa"
];

let mapWidth = MAP_DATA[0].length * TILE_SIZE;
let mapHeight = MAP_DATA.length * TILE_SIZE;

// Câmera
const camera = {
    x: 0,
    y: 0,
    width: canvas.width,
    height: canvas.height
};

/**
 * SISTEMA DE CLIMA (Névoa e Escuridão)
 */
class FogSystem {
    constructor() {
        this.clouds = [];
        // Criar várias nuvens iniciais espalhadas pelo mapa
        for (let i = 0; i < 40; i++) {
            this.clouds.push(this.createCloud(Math.random() * mapWidth));
        }
    }

    createCloud(startX) {
        return {
            x: startX,
            y: Math.random() * mapHeight,
            width: 150 + Math.random() * 250, // Nuvens largas
            height: 80 + Math.random() * 120,
            speed: 0.3 + Math.random() * 0.5, // Movimento lento
            alpha: 0.05 + Math.random() * 0.10 // Transparência bem sutil
        };
    }

    update() {
        this.clouds.forEach(cloud => {
            cloud.x += cloud.speed;
            // Se sair do mapa pela direita, volta para a esquerda
            if (cloud.x > mapWidth) {
                Object.assign(cloud, this.createCloud(-300));
            }
        });
    }

    draw(ctx) {
        this.clouds.forEach(cloud => {
            ctx.globalAlpha = cloud.alpha;
            ctx.fillStyle = '#ecf0f1'; // Cor da névoa (branco gelo)
            ctx.fillRect(cloud.x, cloud.y, cloud.width, cloud.height);
        });
        ctx.globalAlpha = 1.0; // Resetar opacidade
    }
}

/**
 * UTILITÁRIOS
 */
function drawPixelRect(x, y, w, h, color) {
    ctx.fillStyle = color;
    ctx.fillRect(Math.floor(x), Math.floor(y), w, h);
}

// Verifica colisão com paredes do mapa
function isWalkable(x, y) {
    const col = Math.floor(x / TILE_SIZE);
    const row = Math.floor(y / TILE_SIZE);

    // Fora dos limites do mapa é parede
    if (row < 0 || row >= MAP_DATA.length || col < 0 || col >= MAP_DATA[0].length) {
        return false;
    }

    const tile = MAP_DATA[row][col];
    // 'a' é arvore (bloqueia), resto anda
    return tile !== 'a';
}

// Verifica colisão de círculo contra tiles
function checkMapCollision(x, y, radius) {
    // Verifica 4 pontos ao redor do círculo para impedir atravessar paredes
    const points = [
        {x: x - radius * 0.5, y: y}, // Esquerda
        {x: x + radius * 0.5, y: y}, // Direita
        {x: x, y: y - radius * 0.5}, // Cima
        {x: x, y: y + radius * 0.5}  // Baixo
    ];

    for (let p of points) {
        if (!isWalkable(p.x, p.y)) return true;
    }
    return false;
}

/**
 * CLASSES
 */

class Particle {
    constructor(x, y, color, velocity) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.velocity = velocity;
        this.life = 1.0;
        this.size = Math.random() * 4 + 2;
    }

    draw() {
        ctx.globalAlpha = this.life;
        drawPixelRect(this.x, this.y, this.size, this.size, this.color);
        ctx.globalAlpha = 1.0;
    }

    update() {
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
        this.x += this.velocity.x;
        this.y += this.velocity.y;
        this.life -= 0.05;
    }
}

class Player {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.width = 32;
        this.height = 40; 
        this.radius = 16;
        
        this.colors = {
            hair: '#e67e22',
            skin: '#ffcc99',
            shirt: '#27ae60',
            pants: '#2c3e50',
            boots: '#3e2723',
            cloak: '#795548',
            sword: '#bdc3c7',
            swordHilt: '#8e44ad'
        };

        this.speed = 4;
        this.lives = 3;
        this.direction = 0;
        
        this.isAttacking = false;
        this.attackDuration = 15;
        this.attackTimer = 0;
        this.isMoving = false;
        
        this.isInvulnerable = false;
        this.invulnerableTimer = 0;
    }

    update() {
        let dx = 0;
        let dy = 0;
        this.isMoving = false;

        if (keys.w) dy -= 1;
        if (keys.s) dy += 1;
        if (keys.a) dx -= 1;
        if (keys.d) dx += 1;

        if (dx !== 0 || dy !== 0) {
            this.isMoving = true;
            const length = Math.sqrt(dx * dx + dy * dy);
            const moveX = (dx / length) * this.speed;
            const moveY = (dy / length) * this.speed;

            // Colisão Eixo X
            if (!checkMapCollision(this.x + moveX, this.y, this.radius)) {
                this.x += moveX;
            }
            // Colisão Eixo Y
            if (!checkMapCollision(this.x, this.y + moveY, this.radius)) {
                this.y += moveY;
            }
        }

        // Calcular Direção Visual baseada no Mouse (Mouse agora considera a câmera)
        const angle = Math.atan2(mouse.mapY - this.y, mouse.mapX - this.x);
        const deg = angle * (180 / Math.PI);

        if (deg > -45 && deg <= 45) this.direction = 3; 
        else if (deg > 45 && deg <= 135) this.direction = 0;
        else if (deg > 135 || deg <= -135) this.direction = 2;
        else this.direction = 1;

        if (this.isAttacking) {
            this.attackTimer--;
            if (this.attackTimer <= 0) this.isAttacking = false;
        }

        if (this.isInvulnerable) {
            this.invulnerableTimer--;
            if (this.invulnerableTimer <= 0) this.isInvulnerable = false;
        }
    }

    draw() {
        if (this.isInvulnerable && Math.floor(globalFrame / 4) % 2 === 0) return;

        const cx = this.x;
        const cy = this.y;
        
        let bobY = 0;
        let legOffset = 0;
        if (this.isMoving) {
            const walkCycle = Math.sin(globalFrame * 0.3);
            bobY = Math.abs(walkCycle) * 3;
            legOffset = walkCycle * 5;
        }

        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.ellipse(cx, cy + 20, 12, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.save();
        ctx.translate(cx, cy - bobY);

        if (this.direction === 0) this.drawFront(legOffset);
        else if (this.direction === 1) this.drawBack(legOffset);
        else if (this.direction === 2) this.drawSide(legOffset, true);
        else if (this.direction === 3) this.drawSide(legOffset, false);

        ctx.restore();
    }

    drawFront(legOffset) {
        drawPixelRect(-8, 10, 6, 12, this.colors.pants);
        drawPixelRect(2, 10, 6, 12, this.colors.pants);
        drawPixelRect(-9, 20, 8, 4, this.colors.boots);
        drawPixelRect(1, 20, 8, 4, this.colors.boots);
        drawPixelRect(-10, -5, 20, 18, this.colors.shirt);
        drawPixelRect(-12, -4, 4, 18, this.colors.cloak);
        drawPixelRect(8, -4, 4, 18, this.colors.cloak);
        drawPixelRect(-4, -4, 8, 3, this.colors.cloak);
        drawPixelRect(-10, 8, 20, 3, '#1e272e');
        drawPixelRect(-10, -22, 20, 18, this.colors.skin);
        drawPixelRect(-11, -28, 22, 8, this.colors.cloak); 
        drawPixelRect(-12, -26, 4, 20, this.colors.cloak);
        drawPixelRect(8, -26, 4, 20, this.colors.cloak);
        drawPixelRect(-8, -22, 16, 6, this.colors.hair);
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(-6, -14, 4, 4);
        ctx.fillRect(2, -14, 4, 4);
        this.drawSword(14, 5, 0); 
    }

    drawBack(legOffset) {
        this.drawSword(14, 5, 0);
        drawPixelRect(-8, 10, 6, 12, this.colors.pants);
        drawPixelRect(2, 10, 6, 12, this.colors.pants);
        drawPixelRect(-11, -4, 22, 20, this.colors.cloak);
        drawPixelRect(-12, -28, 24, 24, this.colors.cloak);
        drawPixelRect(-4, -10, 8, 6, this.colors.cloak); 
    }

    drawSide(legOffset, isLeft) {
        ctx.save();
        if (isLeft) ctx.scale(-1, 1);
        drawPixelRect(-4 + legOffset, 10, 8, 12, this.colors.pants);
        drawPixelRect(-5 + legOffset, 20, 10, 4, this.colors.boots);
        drawPixelRect(-9, -4, 5, 19, this.colors.cloak);
        drawPixelRect(-5, -5, 11, 18, this.colors.shirt);
        drawPixelRect(-2, -2, 6, 12, this.colors.shirt); 
        drawPixelRect(-2, 8, 6, 4, this.colors.skin); 
        drawPixelRect(-8, -22, 16, 18, this.colors.skin);
        drawPixelRect(-10, -28, 18, 8, this.colors.cloak); 
        drawPixelRect(-12, -28, 8, 24, this.colors.cloak); 
        drawPixelRect(2, -22, 4, 6, this.colors.hair);
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(4, -14, 3, 4);
        this.drawSword(6, 6, isLeft ? -1 : 1);
        ctx.restore();
    }

    drawSword(x, y, sideMultiplier) {
        if (!this.isAttacking) {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.PI / 4);
            drawPixelRect(-2, -10, 4, 8, this.colors.swordHilt);
            drawPixelRect(-3, -2, 6, 2, '#7f8c8d');
            drawPixelRect(-2, 0, 4, 18, this.colors.sword);
            ctx.restore();
        } else {
            const progress = this.attackTimer / this.attackDuration;
            const swingAngle = (Math.PI) * (1 - progress) - (Math.PI/2);
            ctx.save();
            ctx.translate(0, 0);
            ctx.rotate(swingAngle * (sideMultiplier === -1 ? -1 : 1)); 
            const reach = 25;
            drawPixelRect(reach, -2, 24, 6, this.colors.sword);
            drawPixelRect(reach - 6, -4, 6, 10, '#7f8c8d');
            drawPixelRect(reach - 12, -2, 6, 6, this.colors.swordHilt);
            ctx.fillStyle = `rgba(255, 255, 255, ${progress})`;
            ctx.fillRect(reach + 5, -15, 15, 40);
            ctx.restore();
        }
    }

    attack() {
        if (!this.isAttacking) {
            this.isAttacking = true;
            this.attackTimer = this.attackDuration;
        }
    }
}

class Enemy {
    constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type; // 'G' = Goblin, 'S' = Snake
        
        if (this.type === 'S') {
            this.width = 24;
            this.radius = 12;
            this.color = '#2ecc71'; // Verde brilhante
            this.speed = 2.5; // Rápido
        } else {
            // Goblin
            this.width = 30;
            this.radius = 15;
            this.color = '#27ae60'; // Verde escuro
            this.speed = 1.5; // Lento
        }
        
        this.bounceOffset = Math.random() * 100;
    }

    draw() {
        // Offset visual de animação
        const bounce = Math.abs(Math.sin((globalFrame + this.bounceOffset) * 0.1)) * 5;
        const ey = this.y - bounce;

        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 10, this.radius, this.radius/2, 0, 0, Math.PI * 2);
        ctx.fill();

        if (this.type === 'S') {
            // Desenho da Cobra
            drawPixelRect(this.x - 10, ey, 20, 10, this.color); // Corpo deitado
            drawPixelRect(this.x - 5, ey - 10, 10, 10, this.color); // Cabeça erguida
            // Olhos
            ctx.fillStyle = '#c0392b'; // Olho vermelho
            drawPixelRect(this.x, ey - 8, 2, 2, '#c0392b');
            // Lingua
            if (globalFrame % 20 < 10) {
                drawPixelRect(this.x - 1, ey - 4, 2, 6, '#e74c3c');
            }
        } else {
            // Desenho do Goblin
            drawPixelRect(this.x - 12, ey - 20, 24, 20, this.color); // Cabeça/Corpo
            drawPixelRect(this.x - 18, ey - 15, 6, 8, this.color); // Orelha esq
            drawPixelRect(this.x + 12, ey - 15, 6, 8, this.color); // Orelha dir
            
            ctx.fillStyle = '#f1c40f'; // Olhos amarelos
            drawPixelRect(this.x - 6, ey - 12, 4, 4, '#f1c40f');
            drawPixelRect(this.x + 2, ey - 12, 4, 4, '#f1c40f');
            
            // Corpo simples
            drawPixelRect(this.x - 8, ey, 16, 12, '#5d4037'); // Roupa marrom
        }
    }

    update(player) {
        const angle = Math.atan2(player.y - this.y, player.x - this.x);
        
        // Simples IA de perseguição
        const moveX = Math.cos(angle) * this.speed;
        const moveY = Math.sin(angle) * this.speed;

        // Tentar mover X
        if (!checkMapCollision(this.x + moveX, this.y, this.radius)) {
            this.x += moveX;
        }
        // Tentar mover Y
        if (!checkMapCollision(this.x, this.y + moveY, this.radius)) {
            this.y += moveY;
        }
    }
}

/**
 * GERENCIAMENTO DO JOGO
 */
let player;
let enemies = [];
let particles = [];
let fogSystem; // Instância da névoa

function init() {
    enemies = [];
    particles = [];
    score = 0;
    isGameOver = false;
    uiElement.style.display = 'none';
    fogSystem = new FogSystem(); // Inicia a névoa

    // Parse do Mapa
    for (let r = 0; r < MAP_DATA.length; r++) {
        for (let c = 0; c < MAP_DATA[r].length; c++) {
            const char = MAP_DATA[r][c];
            const x = c * TILE_SIZE + TILE_SIZE/2;
            const y = r * TILE_SIZE + TILE_SIZE/2;

            if (char === 'P') {
                player = new Player(x, y);
            } else if (char === 'S') {
                enemies.push(new Enemy(x, y, 'S'));
            } else if (char === 'G') {
                enemies.push(new Enemy(x, y, 'G'));
            }
        }
    }
}

function createExplosion(x, y, color) {
    for (let i = 0; i < 10; i++) {
        particles.push(new Particle(x, y, color, {
            x: (Math.random() - 0.5) * 8,
            y: (Math.random() - 0.5) * 8
        }));
    }
}

function drawUI() {
    // Corações
    for (let i = 0; i < player.lives; i++) {
        const x = 30 + (i * 35);
        const y = 30;
        ctx.fillStyle = '#e74c3c';
        drawPixelRect(x + 5, y, 5, 5, '#e74c3c');
        drawPixelRect(x + 15, y, 5, 5, '#e74c3c');
        drawPixelRect(x, y + 5, 25, 5, '#e74c3c');
        drawPixelRect(x + 5, y + 10, 15, 5, '#e74c3c');
        drawPixelRect(x + 10, y + 15, 5, 5, '#e74c3c');
    }
    // Score
    ctx.fillStyle = 'white';
    ctx.font = '20px "Courier New"';
    ctx.textAlign = 'right';
    ctx.fillText(`SCORE: ${score.toString().padStart(5, '0')}`, canvas.width - 30, 45);
}

function drawMap() {
    // Renderiza apenas tiles visíveis para performance
    const startCol = Math.floor(camera.x / TILE_SIZE);
    const endCol = startCol + (camera.width / TILE_SIZE) + 1;
    const startRow = Math.floor(camera.y / TILE_SIZE);
    const endRow = startRow + (camera.height / TILE_SIZE) + 1;

    for (let row = startRow; row <= endRow; row++) {
        for (let col = startCol; col <= endCol; col++) {
            if (row >= 0 && row < MAP_DATA.length && col >= 0 && col < MAP_DATA[0].length) {
                const char = MAP_DATA[row][col];
                const x = col * TILE_SIZE;
                const y = row * TILE_SIZE;

                // 1. Desenha Chão Base (Fundo mais escuro)
                ctx.fillStyle = '#3e3a36'; // Marrom acinzentado bem escuro (terra/sombra)
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                
                // Detalhe do caminho (Área andável)
                if (char !== 'a') {
                     ctx.fillStyle = '#605850'; // Marrom acinzentado (Trilha)
                     ctx.fillRect(x + 4, y + 4, TILE_SIZE - 8, TILE_SIZE - 8);

                     // Geração Procedural de Detalhes (Baseado na posição para não piscar)
                     // Usamos bitwise operations simples para criar um "número aleatório" fixo para este tile
                     const seed = (col * 11) + (row * 37);
                     const variant = seed % 10;

                     if (variant === 1) { 
                         // Variação 1: Pedras no caminho
                         ctx.fillStyle = '#4a4540'; // Pedra escura
                         drawPixelRect(x + 12, y + 10, 8, 6, '#4a4540');
                         drawPixelRect(x + 35, y + 42, 6, 6, '#4a4540');
                     } 
                     else if (variant === 2) {
                         // Variação 2: Folhas Fantasma Caídas (Brancas/Cinza)
                         ctx.fillStyle = '#bdc3c7'; 
                         drawPixelRect(x + 40, y + 15, 4, 4, '#bdc3c7');
                         drawPixelRect(x + 15, y + 35, 4, 4, '#bdc3c7');
                         drawPixelRect(x + 45, y + 45, 4, 4, '#bdc3c7');
                     }
                     else if (variant === 3) {
                         // Variação 3: Manchas de terra
                         ctx.fillStyle = '#554d46'; 
                         drawPixelRect(x + 20, y + 20, 15, 10, '#554d46');
                     }
                }

                // 2. Desenha Árvores
                if (char === 'a') {
                    // Seed determinística para variar o tipo da árvore baseado na posição (x,y)
                    const seed = (col * 11) + (row * 37);
                    const treeVariant = seed % 5; // Gera números de 0 a 4

                    // Tronco (Comum a todas, mas levemente ajustado)
                    drawPixelRect(x + 26, y + 32, 12, 32, '#2c3e50'); 

                    if (treeVariant === 0) {
                        // === ÁRVORE MORTA (Sem folhas) ===
                        // Galho Central
                        drawPixelRect(x + 30, y + 10, 4, 22, '#2c3e50'); 
                        // Galho Esquerdo
                        drawPixelRect(x + 14, y + 22, 16, 4, '#2c3e50');
                        drawPixelRect(x + 14, y + 14, 4, 8, '#2c3e50'); // Ponta
                        // Galho Direito
                        drawPixelRect(x + 38, y + 18, 14, 4, '#2c3e50');
                        drawPixelRect(x + 48, y + 10, 4, 8, '#2c3e50'); // Ponta
                    } 
                    else if (treeVariant === 1) {
                        // === ÁRVORE COM FRUTOS ===
                        // Folhagem Base
                        drawPixelRect(x + 10, y + 10, 44, 30, '#ecf0f1'); 
                        drawPixelRect(x + 16, y, 32, 20, '#ecf0f1');
                        drawPixelRect(x + 10, y + 35, 44, 5, '#bdc3c7'); // Sombra
                        
                        // Frutos (Cor Roxo Místico para destacar no branco)
                        const fruitColor = '#8e44ad';
                        drawPixelRect(x + 15, y + 20, 6, 6, fruitColor);
                        drawPixelRect(x + 42, y + 25, 6, 6, fruitColor);
                        drawPixelRect(x + 28, y + 8, 6, 6, fruitColor);
                    } 
                    else {
                        // === ÁRVORE PADRÃO ===
                        // Folhas Brancas/Cinza claro (Ghost Forest)
                        drawPixelRect(x + 10, y + 10, 44, 30, '#ecf0f1'); // Camada base
                        drawPixelRect(x + 16, y, 32, 20, '#ecf0f1'); // Topo
                        // Sombra leve nas folhas
                        drawPixelRect(x + 10, y + 35, 44, 5, '#bdc3c7');
                    }
                }
            }
        }
    }
}

function updateCamera() {
    // Centraliza no player
    camera.x = player.x - canvas.width / 2;
    camera.y = player.y - canvas.height / 2;

    // Trava nos limites do mapa
    camera.x = Math.max(0, Math.min(camera.x, mapWidth - canvas.width));
    camera.y = Math.max(0, Math.min(camera.y, mapHeight - canvas.height));
    
    // Se o mapa for menor que a tela, centraliza o mapa
    if(mapWidth < canvas.width) camera.x = -(canvas.width - mapWidth) / 2;
    if(mapHeight < canvas.height) camera.y = -(canvas.height - mapHeight) / 2;
}

function animate() {
    if (isGameOver) return;
    
    animationId = requestAnimationFrame(animate);
    globalFrame++;

    // Limpa tela
    ctx.fillStyle = '#050510'; // Fundo do canvas (fora do mapa) ainda mais escuro
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    updateCamera();

    // === INICIO DO MUNDO DO JOGO ===
    ctx.save();
    ctx.translate(-camera.x, -camera.y);

    drawMap();

    // Ordenar entidades por Y
    const entities = [...enemies, player].sort((a, b) => a.y - b.y);

    player.update();

    entities.forEach(entity => {
        if (entity === player) {
            player.draw();
        } else {
            entity.update(player);
            entity.draw();
        }
    });

    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw();
        if (p.life <= 0) particles.splice(i, 1);
    }

    // --- EFEITOS ATMOSFÉRICOS ---
    
    // 1. Escuridão Global (Noite/Ambiente Dark)
    // Desenhamos um retângulo preto semi-transparente sobre toda a área visível
    ctx.fillStyle = 'rgba(0, 5, 20, 0.45)'; 
    ctx.fillRect(camera.x, camera.y, camera.width, camera.height);

    // 2. Névoa Passando
    fogSystem.update();
    fogSystem.draw(ctx);

    // Colisões e Lógica de Combate
    for (let i = enemies.length - 1; i >= 0; i--) {
        const enemy = enemies[i];
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);

        if (dist < player.radius + enemy.radius) {
            if (!player.isInvulnerable) {
                player.lives--;
                player.isInvulnerable = true;
                player.invulnerableTimer = 60;
                createExplosion(player.x, player.y, '#e74c3c');
                if (player.lives <= 0) endGame();
            }
        }

        if (player.isAttacking && dist < 60) {
            const angleToEnemy = Math.atan2(enemy.y - player.y, enemy.x - player.x);
            let playerAngle = 0;
            if (player.direction === 0) playerAngle = Math.PI/2;
            if (player.direction === 1) playerAngle = -Math.PI/2;
            if (player.direction === 2) playerAngle = Math.PI;
            if (player.direction === 3) playerAngle = 0;

            const angleDiff = Math.abs(angleToEnemy - playerAngle);
            
            if (angleDiff < 1.5 || (player.direction === 2 && Math.abs(angleToEnemy) > 2)) {
                 createExplosion(enemy.x, enemy.y, enemy.color);
                 enemies.splice(i, 1);
                 score += 100;
            }
        }
    }

    ctx.restore(); 
    // === FIM DO MUNDO DO JOGO ===

    drawUI();
}

function endGame() {
    isGameOver = true;
    uiElement.style.display = 'block';
}

// Controles
window.addEventListener('keydown', e => {
    if (e.key === 'w') keys.w = true;
    if (e.key === 'a') keys.a = true;
    if (e.key === 's') keys.s = true;
    if (e.key === 'd') keys.d = true;
    if (e.key === ' ') {
        if (isGameOver) {
            init();
            animate();
        }
    }
});

window.addEventListener('keyup', e => {
    if (e.key === 'w') keys.w = false;
    if (e.key === 'a') keys.a = false;
    if (e.key === 's') keys.s = false;
    if (e.key === 'd') keys.d = false;
});

window.addEventListener('mousemove', e => {
    // Calcula posição do mouse relativa ao mundo (considerando a câmera)
    mouse.mapX = e.clientX + camera.x;
    mouse.mapY = e.clientY + camera.y;
});

window.addEventListener('mousedown', () => {
    if (!isGameOver) player.attack();
});

window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    camera.width = canvas.width;
    camera.height = canvas.height;
});

init();
animate();

</script>
</body>
</html>